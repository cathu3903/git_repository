/***********************************************************************/
/*                                                                     */
/*  FILE        :test_compil.c                                         */
/*  DATE        :Fri, Sep 29, 2006                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :87                                                    */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.5).     */
/*   m308															   */
/*   nc308lib														   */
/*   c308mr															   */
/*   nc382lib														   */
/*                                                                     */
/***********************************************************************/
#include "sfr32c87.h"
#include <stdio.h>
#include <stdlib.h>
#include <itron.h>
#include <kernel.h>
#include "kernel_id.h"
#include "lcd.h"
#include "clavier.h"
#include "periph.h"
#include "uart0.h"
#include "can.h"
#include "carte_io.h"
#include "carte_m32.h"
#include <math.h>

// Potentiometre: lire les registres ad00 et ad01, les valeurs sont sur 10 bits.

// Clavier: vrcv_dtq(QdmTouche,&code_touche) pour lire la derniere touche appuyee sur le clavier.
// 			la variable code_touche doit etre du type short.

// Bouton poussoir: Bp_G, Bp_M, Bp_D permettent de lire l'etat des boutons de la carte I/O

// Leds: LED_R=1 ou LED_R=0 Pour allumer ou eteindre les leds (LED_R, LED_J, LED_V).

// Pour communiquer avec le simulateur utiliser une variable de type CanFrame,
// Definir les differents champs en utilisant la structure (S)eparee (comm.data)
// Envoyer le message complet en utilisant l'union (comm.msg)

// Exemple:
// 		CanFrame comm;
//			comm.data.id='T'; comm.data.rtr=0; comm.data.val=-100;
//			snd_dtq (CanTx,comm.msg);

// Pour interroger un peripherique et recuperer les donnees brutes renvoyees simulateur:
//		CanFrame demande;
//		CanFrame reponse;
//
//			demande.data.id='R'; demande.data.rtr=1;
//			snd_dtq (CanTx,demande.msg); // Interrogation du peripherique
// 			rcv_dtq (CanRx,&reponse.msg); // Attente de la reponse
// 			reponse.data.val contient la valeur de retour du simulateur.
// ATTENTION: Ne pas utiliser rcv_dtq(CanRx... si la tache ID_periph_rx est active

// Lors de l'utilisation de la tache de reception et distribution des messages ID_periph_rx
// Demarrer cette tache : sta_tsk(ID_periph_rx);
// Pour lire la valeur d'un peripherique:
// Il faut envoyer une demande de lecture:
// 	CanFrame comm;
// 		comm.data.id='R'; comm.data.rtr=1;
// 		snd_dtq (CanTx,comm.msg);
//
// Des l'arrivee de la reponse du simlateur, les variables suivantes sont mises a jour:
// periph[ADDR('R')].val : contient la derniere valeur renvoyee par le simulateur.
//
// Pour verifier si une nouvelle valeur a ete recue utiliser:
// periph[ADDR('R')].maj (incremente a chaque reception).

// Pour qu'un evenement soit declenche lors de la reception d'une donnee pour un peripherique:
// periph[ADDR('R')].ev=0x01;
// Pour se mettre en attente de l'evenement: wai_flg (ev_periph,0x0001,TWF_ORW,&flag); // Declarer la variable flag comme : FLGPTN flag
// Attention l'evenement n'est pas efface apres reception, il faut donc utiliser clr_flg(ev_periph,~(flag & 0x0001)); par example

// Les evenements:
// Si le simulateur envoi un evenement sur 16 bits il est recu grace a:
// par exemple:  wai_flg(event,(FLGPTN) 0x0007,TWF_ORW,&flag); // Declarer la variable flag comme : FLGPTN flag
// Attention l'evenement n'est pas efface apres reception, il faut donc utiliser clr_flg(event,~(flag & 0x0007)); par example
//Bit   Information associee            Remarque
//0     Capteur Vert,                   remis a zero lors de la lecture du peripherique 'C'
//1     Capteur Jaune,                  remis a zero lors de la lecture du peripherique 'C'
//2     Capteur Rouge,                  remis a zero lors de la lecture du peripherique 'C'
//3     Capteur Bleu,                   remis a zero lors de la lecture du peripherique 'C'
//4     Capteur Cyan,                   remis a zero lors de la lecture du peripherique 'C'
//5
//6     Collision avec le sol,          remise a zero au changement de piste.
//7     Fin de course (capteur vert),   remis a zero lors de la lecture du peripherique 'C'
//8     La piste a change ,             remis a zero lors de la lecture du peripherique 'M'
//9     Le mode de course a change ,    remis a zero lors de la lecture du peripherique 'M'
//10
//11    Le vehicule a termine un tour,   remis a zero au changement du mode de course.
//12    Sortie de la piste,
//13    Teleportation a ete utilisee,   remis a zero au changement de piste ou du mode de course.
//14    Faux depart                     remise a zero au changement du mode de course.
//15


// Peripheriques disponibles:
//'V'/86/0x56? Commande en vitesse des roues motrices du vehicule (en radian /secondes).
//'D'/68/0x44? Commande de l'angle des roues directrices (en 1/10 de degre).
//'T'/84/0x54? Commande en vitesse de la tourelle portant le telemetre (en 1/10 de degre/secondes).
//'R'/82/0x52? Lecture de l'angle effectif de la tourelle portant le telemetre (en 1/10 de degre).
//'U'/85/0x55? Distance mesuree par le telemetre (1/100 de metre)
//'N'/78/0x4E? Numero de la voiture (en fonction de l'ordre de connexion)
//'E'/69/0x45? Lecture des evenements,
//'H'/72/0x48? Donne le temps de course actuel
//'S'/83/0x53? Temps du tour precedent
//'M'/77/0x7D? Mode de course :
//  Bit 15? Etat feu tricolore ( 1 -> Vert, 0 -> Orange ou Rouge),
//  Bits 14-8? 1 Attente, 2 course, 3 essais libres)
//  Bits 7-0? numero de la piste
//'C'/67/0x43? Informations sur le dernier capteur touche :
//  8 bits de poids faible? numero du capteur
//  8 bits de poids fort? couleur ('C','R','J','B' ou 'V')
//'J'/74/0x4A : Proposition d'un code de d??ouillage.
//				Une valeur de 0 ?5 par quartet
//'j'/106/06A : R?up?ation du r?ultat de dernier code envoy?
//				0x77 si aucun code n'a ??soumis.
//				<0 si la r?onse n'est pas
//				disponible. 0x0a0b avec a-> nombre de couleurs bien plac?s et b -> couleurs pr?entes mais mal plac?s.
//'I'/73/Ox49 : D?inition du nom du v?icule. Doit d?uter par le caract?e '#' et entraine le chargement de la configuration de piste
//

/*
Temps mis pour faire un tour: 23s
nombre de messages generes par secondes: 7350

*/
void tourelle()
{
    UINT flag;
    CanFrame demande;
    CanFrame comm;
    short erreur;
	short tourelle;
	short k = 1;

	periph[ADDR('R')].ev=0x01;
    while(1){

	    demande.data.id='R';
	    demande.data.rtr=1;
	    snd_dtq(CanTx,demande.msg);

	    wai_flg(ev_periph, 0x01, TWF_ANDW, &flag);
	    clr_flg(ev_periph,~((flag & 0x01)));
	    tourelle=periph[ADDR('R')].val;

	    erreur=k*(450-tourelle);


	    comm.data.id='T';
	    comm.data.rtr=0;
	    comm.data.val=erreur;
	    snd_dtq(CanTx,comm.msg);

	}
}
/* void direction()
{
    UINT flag;
	CanFrame demande;
	CanFrame comm;
	short ecart;
	short commende;
	short reponse;

    periph[ADDR('U')].ev=0x02;
	while(1){
		demande.data.id='U';
	    demande.data.rtr=1;
	    snd_dtq(CanTx,demande.msg);

	    wai_flg(ev_periph, 0x02, TWF_ANDW, &flag);
	    clr_flg(ev_periph,~((flag & 0x02)));

	    reponse = periph[ADDR('U')].val;

	    ecart = reponse - 707;


	    comm.data.id='D';
	    comm.data.rtr=0;
	    comm.data.val=ecart;
	    snd_dtq(CanTx,comm.msg);
	}

} */

void vitesse(){
	CanFrame demande;
   	while(1){
	    demande.data.id = 'V';
		demande.data.rtr = 0;
		demande.data.val = 40;
		snd_dtq(CanTx, demande.msg);
	}
}


void main()
{

    ports_mcu();
    lcd_init();
	periph_init();
	periph_nom("#AutoTest*");

    can_init();
    clavier_init(1);
	capture_init();

	sta_cyc(ID_acqui);
	sta_tsk(ID_periph_rx);
  	sta_tsk(ID_tourelle);
	dly_tsk(1000);
    sta_tsk(ID_direction);
    sta_tsk(ID_vitesse);


}

void acqui()
{
	LED_V=!LED_V;
}